"use client";
import { useFlowStore } from "@/store/flowStore";
import {
  Background,
  Controls,
  ReactFlow,
  addEdge,
  applyEdgeChanges,
  applyNodeChanges,
} from "@xyflow/react";
import "@xyflow/react/dist/style.css";
import { useCallback, useState } from "react";
import ApiCallNode from "./CustomNodes/ApiCallNode";
import ConditionNode from "./CustomNodes/ConditionNode";
import DelayNode from "./CustomNodes/DelayNode";
import PythonNode from "./CustomNodes/PythonNode";
import dagre from "dagre";

const nodeTypes = {
  apiCall: ApiCallNode,
  condition: ConditionNode,onNodeClick
  delay: DelayNode,
  python: PythonNode,
};

export default function FlowCanvas() {
  const transformNodes = (nodes) =>
    nodes.map((node) => ({
      ...node.data,
      id: node.id,
      type: node.type,
      position: node.position,
    }));

  const {
    nodes,
    edges,
    setNodes,
    setEdges,
    setSelectedNode,
    deleteSelectedNode,
    clearSelection,
    setSelectedEdge,
    deleteSelectedEdge,
    selectedEdge,
    clearEdgeSelection,
  } = useFlowStore();

  const onEdgeClick = useCallback(
    (event, edge) => {
      setSelectedEdge(edge);
    },
    [setSelectedEdge]
  );

  const backendUrl =
    process.env.NEXT_PUBLIC_BACKEND_URL || "http://localhost:8000";

  // --- Run workflow states ---
  const [error, setError] = useState(null);
  const [workflowOutput, setWorkflowOutput] = useState(null);

  // --- Validate workflow states ---
  const [validateResult, setValidateResult] = useState(null);
  const [validateLoading, setValidateLoading] = useState(false);
  const [validateError, setValidateError] = useState(null);

  // --- Execute workflow states ---
  const [executeResult, setExecuteResult] = useState(null);
  const [executeLoading, setExecuteLoading] = useState(false);
  const [executeError, setExecuteError] = useState(null);

  // --- Generate workflow states ---
  const [generateResult, setGenerateResult] = useState(null);
  const [generateLoading, setGenerateLoading] = useState(false);
  const [generateError, setGenerateError] = useState(null);

  const getLayoutedElements = (nodes, edges, direction = "TB") => {
    // If no nodes, return as-is
    if (!nodes || nodes.length === 0) {
      return { nodes: [], edges: edges || [] };
    }

    const dagreGraph = new dagre.graphlib.Graph();
    dagreGraph.setDefaultEdgeLabel(() => ({}));
    dagreGraph.setGraph({
      rankdir: direction,
      nodesep: 50,
      ranksep: 50,
      marginx: 20,
      marginy: 20,
    });

    // Add nodes with validation
    const nodeWidth = 180;
    const nodeHeight = 60;

    nodes.forEach((node) => {
      if (node.id) {
        dagreGraph.setNode(node.id, {
          width: nodeWidth,
          height: nodeHeight,
        });
      }
    });

    // Add edges with validation - avoid duplicates and ensure nodes exist
    const addedEdges = new Set();
    const validEdges = [];

    (edges || []).forEach((edge) => {
      const edgeKey = `${edge.source}-${edge.target}`;

      // Skip if edge already added, or if source/target nodes don't exist
      if (
        addedEdges.has(edgeKey) ||
        edge.source === edge.target ||
        !dagreGraph.hasNode(edge.source) ||
        !dagreGraph.hasNode(edge.target)
      ) {
        return;
      }

      dagreGraph.setEdge(edge.source, edge.target);
      addedEdges.add(edgeKey);
      validEdges.push(edge);
    });

    try {
      dagre.layout(dagreGraph);
    } catch (error) {
      console.error("Dagre layout error:", error);
      // Fallback to simple positioning
      return {
        nodes: nodes.map((node, index) => ({
          ...node,
          position: { x: index * 200, y: 100 },
        })),
        edges: validEdges,
      };
    }

    const layoutedNodes = nodes.map((node) => {
      if (!node.id || !dagreGraph.hasNode(node.id)) {
        // Fallback position for nodes that couldn't be laid out
        return {
          ...node,
          position: node.position || { x: 0, y: 0 },
        };
      }

      const { x, y } = dagreGraph.node(node.id);
      return {
        ...node,
        position: {
          x: x - nodeWidth / 2,
          y: y - nodeHeight / 2,
        },
      };
    });

    return { nodes: layoutedNodes, edges: validEdges };
  };

  // --- Validate Workflow ---
  const validateWorkflow = async () => {
    setValidateLoading(true);
    setValidateError(null);
    setValidateResult(null);
    try {
      const response = await fetch(`${backendUrl}/workflow/validate`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ nodes: transformNodes(nodes), edges }),
      });
      if (!response.ok) throw new Error("Validation failed");
      const data = await response.json();
      setValidateResult(data.message || JSON.stringify(data, null, 2));
    } catch (err) {
      setValidateError(err.message);
    } finally {
      setValidateLoading(false);
    }
  };

  // --- Execute Workflow ---
  const executeWorkflow = async () => {
    setExecuteLoading(true);
    setExecuteError(null);
    setExecuteResult(null);
    try {
      const response = await fetch(`${backendUrl}/workflow/execute`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ nodes: transformNodes(nodes), edges }),
      });
      if (!response.ok) throw new Error("Execution failed");
      const data = await response.json();
      setExecuteResult(data.result || JSON.stringify(data, null, 2));
    } catch (err) {
      setExecuteError(err.message);
    } finally {
      setExecuteLoading(false);
    }
  };

  // --- Generate Workflow (FIXED) ---
  const generateWorkflow = async () => {
    const userInput = prompt("Enter input for workflow generation:");
    if (!userInput) return;

    setGenerateLoading(true);
    setGenerateError(null);
    setGenerateResult(null);

    try {
      // console.log("Sending request to:", `${backendUrl}/workflow/generate`);
      // console.log("User input:", userInput);

      const response = await fetch(`${backendUrl}/workflow/generate`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ user_input: userInput }),
      });

      console.log("Response status:", response.status);

      if (!response.ok) {
        const errorText = await response.text();
        console.error("Response error:", errorText);
        throw new Error(`Generation failed: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      // console.log("Received data:", data);

      const workflow = data?.workflow || data?.generated || data;

      // Check if workflow has nodes and edges
      if (!workflow || !workflow.nodes || !Array.isArray(workflow.nodes)) {
        console.error("Invalid workflow structure:", workflow);
        throw new Error("Invalid workflow structure received from backend");
      }

      console.log("Processing workflow:", workflow);

      // --- Map workflow JSON to React Flow format with autofill configs ---
      const mappedNodes = workflow.nodes.map((n, i) => {
        console.log("Processing node:", n);

        let nodeData = {
          label: n.label || `${n.type || "Node"} (${n.id || i})`,
          ...n, // copy all fields from backend
        };

        // Autofill missing config fields based on type
        switch (n.type) {
          case "apiCall":
            nodeData.url = nodeData.url || "https://example.com/api";
            nodeData.method = nodeData.method || "GET";
            break;
          case "python":
            nodeData.code = nodeData.code || "# Enter your Python code here";
            break;
          case "condition":
            nodeData.condition = nodeData.condition || "x > 0";
            break;
          case "delay":
            nodeData.duration = nodeData.duration || 1000;
            break;
          default:
            break;
        }

        return {
          id: n.id ? n.id.toString() : `node-${i}`,
          type: n.type || "default",
          position: n.position || { x: i * 200, y: 100 },
          data: nodeData,
        };
      });

      const mappedEdges = (workflow.edges || []).map((e, i) => ({
        id: e.id ? e.id.toString() : `edge-${i}`,
        source: e.source || e.from || "",
        target: e.target || e.to || "",
        type: "smoothstep",
      }));

      console.log("Mapped nodes:", mappedNodes);
      console.log("Mapped edges:", mappedEdges);

      // Apply layout if we have nodes
      if (mappedNodes.length > 0) {
        try {
          const { nodes: layoutedNodes, edges: layoutedEdges } =
            getLayoutedElements(mappedNodes, mappedEdges, "TB");

          console.log("Setting nodes and edges...");
          setNodes(layoutedNodes);
          setEdges(layoutedEdges);
          setGenerateResult(JSON.stringify(workflow, null, 2));
        } catch (layoutError) {
          console.error("Layout error, using simple positioning:", layoutError);
          // Fallback to simple positioning
          const simpleNodes = mappedNodes.map((node, index) => ({
            ...node,
            position: { x: index * 200, y: 100 },
          }));
          setNodes(simpleNodes);
          setEdges(mappedEdges);
          setGenerateResult(JSON.stringify(workflow, null, 2));
        }
      } else {
        throw new Error("No nodes found in generated workflow");
      }
    } catch (err) {
      console.error("Generate workflow error:", err);
      setGenerateError(err.message);
    } finally {
      setGenerateLoading(false);
    }
  };

  // --- ReactFlow handlers ---
  const onNodesChange = useCallback(
    (changes) =>
      setNodes((nds) =>
        applyNodeChanges(changes, Array.isArray(nds) ? nds : [])
      ),
    [setNodes]
  );

  const onEdgesChange = useCallback(
    (changes) =>
      setEdges((eds) =>
        applyEdgeChanges(changes, Array.isArray(eds) ? eds : [])
      ),
    [setEdges]
  );

  const onSelectionChange = useCallback(
    ({ nodes: selectedNodes }) => {
      if (Array.isArray(selectedNodes) && selectedNodes.length > 0) {
        setSelectedNode(selectedNodes[0]);
      } else {
        clearSelection();
      }
    },
    [setSelectedNode, clearSelection]
  );

  const onConnect = useCallback(
    (connection) => {
      setEdges((eds) => addEdge({ ...connection, type: "smoothstep" }, eds));
    },
    [setEdges]
  );

  const onDrop = useCallback(
    (event) => {
      event.preventDefault();
      const type = event.dataTransfer.getData("application/reactflow");
      const position = { x: event.clientX - 250, y: event.clientY - 50 };

      let newNode = {
        id: `${+new Date()}`,
        type,
        position,
        data: { label: `${type} node` },
      };

      // Add required fields based on node type to both data and top level
      switch (type) {
        case "apiCall":
          newNode.data.url = "https://example.com/api";
          newNode.data.method = "GET";
          break;
        case "python":
          newNode.data.code = "# Enter your Python code here";
          break;
        case "condition":
          newNode.data.condition = "x > 0";
          break;
        case "delay":
          newNode.data.duration = 1000;
          break;
        default:
          break;
      }

      setNodes((nds) => nds.concat(newNode));
    },
    [setNodes]
  );

  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
  }, []);

  const onKeyDown = useCallback(
    (e) => {
      if (e.key === "Delete" || e.key === "Backspace") {
        deleteSelectedNode();
      }
    },
    [deleteSelectedNode]
  );

  return (
    <div className="flex-1 h-screen flex flex-col">
      {/* Top Bar */}
      <div className="p-4 flex items-center gap-4 bg-gray-50 border-b">
        <button
          onClick={validateWorkflow}
          className="px-4 py-2 bg-blue-600 text-white rounded shadow hover:bg-blue-700 transition"
          disabled={validateLoading}
        >
          {validateLoading ? "Validating..." : "Validate"}
        </button>
        <button
          onClick={executeWorkflow}
          className="px-4 py-2 bg-purple-600 text-white rounded shadow hover:bg-purple-700 transition"
          disabled={executeLoading}
        >
          {executeLoading ? "Executing..." : "Execute"}
        </button>
        <button
          onClick={generateWorkflow}
          className="px-4 py-2 bg-orange-600 text-white rounded shadow hover:bg-orange-700 transition"
          disabled={generateLoading}
        >
          {generateLoading ? "Generating..." : "Generate"}
        </button>

        {(error || validateError || executeError || generateError) && (
          <span className="text-red-500 text-sm">
            {error || validateError || executeError || generateError}
          </span>
        )}
      </div>

      {/* Canvas */}
      <div
        className="flex-1"
        onDrop={onDrop}
        onDragOver={onDragOver}
        onKeyDown={(e) => {
          if ((e.key === "Delete" || e.key === "Backspace") && selectedEdge) {
            deleteSelectedEdge();
            clearEdgeSelection();
          } else {
            onKeyDown(e);
          }
        }}
        tabIndex={0}
      >
        <ReactFlow
          nodes={Array.isArray(nodes) ? nodes : []}
          edges={Array.isArray(edges) ? edges : []}
          nodeTypes={nodeTypes}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onSelectionChange={onSelectionChange}
          onConnect={onConnect}
          onEdgeClick={onEdgeClick}
          connectionMode="loose"
          defaultEdgeOptions={{ type: "smoothstep" }}
          fitView
        >
          <Background variant="dots" gap={12} size={2} />
          <Controls />
        </ReactFlow>
      </div>

      {/* Outputs Section */}
      <div className="p-4 border-t bg-white shadow-inner space-y-4 max-h-80 overflow-y-auto">
        {workflowOutput && (
          <OutputBlock title="Workflow Output" content={workflowOutput} />
        )}
        {validateResult && (
          <OutputBlock title="Validation Result" content={validateResult} />
        )}
        {executeResult && (
          <OutputBlock title="Execution Result" content={executeResult} />
        )}
      </div>
    </div>
  );
}

function OutputBlock({ title, content }) {
  return (
    <div>
      <h3 className="font-bold mb-2 text-lg text-green-700">{title}</h3>
      <pre className="bg-gray-100 p-3 rounded text-sm overflow-auto">
        {typeof content === "string"
          ? content
          : JSON.stringify(content, null, 2)}
      </pre>
    </div>
  );
}
